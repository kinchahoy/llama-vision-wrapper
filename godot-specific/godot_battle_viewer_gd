extends Control
class_name BattleViewer3D

# Battle data and state
var battle_data: Dictionary = {}
var timeline: Array = []
var metadata: Dictionary = {}
var current_frame: float = 0.0
var playing: bool = false
var playback_speed: float = 1.0
var selected_bot: Dictionary = {}

# Scene references - will be set in _ready()
var viewport_3d: SubViewport
var camera_3d: Camera3D
var camera_controller: Node3D
var world_root: Node3D
var lighting: Node3D

# UI references - will be set in _ready()
var play_button: Button
var timeline_slider: HSlider
var left_panel: Panel
var right_panel: Panel
var fps_label: Label
var bot_info_label: RichTextLabel
var tactical_info_label: RichTextLabel
var battle_info_label: RichTextLabel
var events_label: RichTextLabel

# 3D objects
var bot_nodes: Dictionary = {}
var projectile_nodes: Dictionary = {}
var wall_nodes: Array = []
var fov_indicator: MeshInstance3D = null

# Materials
var bot_material_blue: StandardMaterial3D
var bot_material_red: StandardMaterial3D
var projectile_material_blue: StandardMaterial3D
var projectile_material_red: StandardMaterial3D
var wall_material: StandardMaterial3D
var floor_material: StandardMaterial3D

# Camera control
var camera_target: Vector3 = Vector3.ZERO
var camera_distance: float = 25.0
var camera_angle_h: float = 0.0
var camera_angle_v: float = -45.0
var is_panning: bool = false
var last_mouse_pos: Vector2

func _ready():
	print("BattleViewer3D _ready() called")
	add_to_group("battle_viewer")
	
	# Get node references
	get_node_references()
	
	setup_modern_materials()
	setup_lighting()
	setup_ui_styling()
	
	print("BattleViewer3D setup complete, waiting for data...")
	
	# Set some default values
	current_frame = 0.0
	playing = false
	selected_bot = {}
	
	# Try to load test data if no data arrives
	await get_tree().create_timer(2.0).timeout
	if timeline.is_empty():
		print("No battle data loaded, creating test scene...")
		create_test_scene()

func get_node_references():
	print("Getting node references...")
	viewport_3d = get_node_or_null("VBoxContainer/MainArea/ViewportContainer/SubViewport")
	camera_controller = get_node_or_null("VBoxContainer/MainArea/ViewportContainer/SubViewport/CameraController")
	camera_3d = get_node_or_null("VBoxContainer/MainArea/ViewportContainer/SubViewport/CameraController/Camera3D")
	world_root = get_node_or_null("VBoxContainer/MainArea/ViewportContainer/SubViewport/World")
	lighting = get_node_or_null("VBoxContainer/MainArea/ViewportContainer/SubViewport/Lighting")
	
	play_button = get_node_or_null("VBoxContainer/BottomPanel/Toolbar/PlayButton")
	timeline_slider = get_node_or_null("VBoxContainer/BottomPanel/Timeline/TimelineSlider")
	left_panel = get_node_or_null("VBoxContainer/MainArea/LeftPanel")
	right_panel = get_node_or_null("VBoxContainer/MainArea/RightPanel")
	fps_label = get_node_or_null("VBoxContainer/MainArea/LeftPanel/VBoxContainer/FPSLabel")
	bot_info_label = get_node_or_null("VBoxContainer/MainArea/LeftPanel/VBoxContainer/BotInfoLabel")
	tactical_info_label = get_node_or_null("VBoxContainer/MainArea/LeftPanel/VBoxContainer/TacticalInfoLabel")
	battle_info_label = get_node_or_null("VBoxContainer/MainArea/RightPanel/VBoxContainer/BattleInfoLabel")
	events_label = get_node_or_null("VBoxContainer/MainArea/RightPanel/VBoxContainer/EventsLabel")
	
	# Check if we got all the references
	var missing_nodes = []
	if not viewport_3d: missing_nodes.append("viewport_3d")
	if not camera_3d: missing_nodes.append("camera_3d")  
	if not world_root: missing_nodes.append("world_root")
	if not play_button: missing_nodes.append("play_button")
	
	if missing_nodes.size() > 0:
		print("Warning: Missing nodes: ", missing_nodes)
	else:
		print("All node references found successfully!")

func setup_modern_materials():
	# Vibrant bot materials with modern PBR properties
	bot_material_blue = StandardMaterial3D.new()
	bot_material_blue.albedo_color = Color(0.2, 0.6, 1.0, 1.0)
	bot_material_blue.metallic = 0.3
	bot_material_blue.roughness = 0.2
	bot_material_blue.emission_enabled = true
	bot_material_blue.emission = Color(0.1, 0.3, 0.5, 1.0)
	bot_material_blue.rim_enabled = true
	bot_material_blue.rim = Color(0.4, 0.8, 1.0, 1.0)
	bot_material_blue.rim_tint = 0.5
	
	bot_material_red = StandardMaterial3D.new()
	bot_material_red.albedo_color = Color(1.0, 0.3, 0.2, 1.0)
	bot_material_red.metallic = 0.3
	bot_material_red.roughness = 0.2
	bot_material_red.emission_enabled = true
	bot_material_red.emission = Color(0.5, 0.1, 0.1, 1.0)
	bot_material_red.rim_enabled = true
	bot_material_red.rim = Color(1.0, 0.5, 0.3, 1.0)
	bot_material_red.rim_tint = 0.5
	
	# Glowing projectile materials
	projectile_material_blue = StandardMaterial3D.new()
	projectile_material_blue.albedo_color = Color(0.3, 0.8, 1.0, 1.0)
	projectile_material_blue.emission_enabled = true
	projectile_material_blue.emission = Color(0.5, 1.2, 2.0, 1.0)
	projectile_material_blue.metallic = 0.8
	projectile_material_blue.roughness = 0.1
	
	projectile_material_red = StandardMaterial3D.new()
	projectile_material_red.albedo_color = Color(1.0, 0.4, 0.8, 1.0)
	projectile_material_red.emission_enabled = true
	projectile_material_red.emission = Color(2.0, 0.8, 1.2, 1.0)
	projectile_material_red.metallic = 0.8
	projectile_material_red.roughness = 0.1
	
	# Modern wall material with subtle metallic finish
	wall_material = StandardMaterial3D.new()
	wall_material.albedo_color = Color(0.4, 0.45, 0.55, 1.0)
	wall_material.metallic = 0.6
	wall_material.roughness = 0.3
	wall_material.normal_enabled = true
	
	# Floor material with subtle grid pattern
	floor_material = StandardMaterial3D.new()
	floor_material.albedo_color = Color(0.15, 0.16, 0.20, 1.0)
	floor_material.metallic = 0.1
	floor_material.roughness = 0.8

func setup_lighting():
	print("Setting up lighting...")
	if not lighting:
		print("Error: lighting node not found!")
		return
		
	# Modern lighting setup with multiple light sources
	
	# Main directional light (sun)
	var sun_light = DirectionalLight3D.new()
	sun_light.light_energy = 1.2
	sun_light.light_color = Color(1.0, 0.95, 0.8, 1.0)
	sun_light.shadow_enabled = true
	sun_light.directional_shadow_mode = DirectionalLight3D.SHADOW_ORTHOGONAL
	sun_light.rotation_degrees = Vector3(-45, 45, 0)
	lighting.add_child(sun_light)
	
	# Fill light from opposite direction
	var fill_light = DirectionalLight3D.new()
	fill_light.light_energy = 0.3
	fill_light.light_color = Color(0.8, 0.9, 1.0, 1.0)
	fill_light.rotation_degrees = Vector3(-20, -135, 0)
	lighting.add_child(fill_light)
	
	# Ambient lighting
	var environment = Environment.new()
	environment.background_mode = Environment.BG_SKY
	environment.sky = Sky.new()
	environment.sky.sky_material = ProceduralSkyMaterial.new()
	environment.sky.sky_material.sky_top_color = Color(0.2, 0.25, 0.35, 1.0)
	environment.sky.sky_material.sky_horizon_color = Color(0.6, 0.7, 0.8, 1.0)
	environment.ambient_light_color = Color(0.3, 0.35, 0.4, 1.0)
	environment.ambient_light_energy = 0.3
	
	# Modern post-processing effects
	environment.tonemap_mode = Environment.TONE_MAPPER_ACES
	environment.glow_enabled = true
	environment.glow_intensity = 1.0
	environment.glow_strength = 0.8
	environment.glow_bloom = 0.1
	environment.ssao_enabled = true
	environment.ssao_radius = 1.0
	environment.ssao_intensity = 1.0
	
	if camera_3d:
		camera_3d.environment = environment
	else:
		print("Warning: camera_3d not found, cannot set environment")

func setup_ui_styling():
	print("Setting up UI styling...")
	# Apply modern styling to UI elements
	var style_box_panel = StyleBoxFlat.new()
	style_box_panel.bg_color = Color(0.08, 0.10, 0.14, 0.95)
	style_box_panel.border_width_left = 2
	style_box_panel.border_width_right = 2
	style_box_panel.border_width_top = 2
	style_box_panel.border_width_bottom = 2
	style_box_panel.border_color = Color(0.25, 0.35, 0.45, 1.0)
	style_box_panel.corner_radius_top_left = 8
	style_box_panel.corner_radius_top_right = 8
	style_box_panel.corner_radius_bottom_left = 8
	style_box_panel.corner_radius_bottom_right = 8
	
	if left_panel:
		left_panel.add_theme_stylebox_override("panel", style_box_panel)
	if right_panel:
		right_panel.add_theme_stylebox_override("panel", style_box_panel.duplicate())
	
	# Style buttons with modern gradient appearance
	var button_style = StyleBoxFlat.new()
	button_style.bg_color = Color(0.15, 0.45, 0.75, 1.0)
	button_style.border_width_left = 1
	button_style.border_width_right = 1
	button_style.border_width_top = 1
	button_style.border_width_bottom = 1
	button_style.border_color = Color(0.3, 0.6, 0.9, 1.0)
	button_style.corner_radius_top_left = 6
	button_style.corner_radius_top_right = 6
	button_style.corner_radius_bottom_left = 6
	button_style.corner_radius_bottom_right = 6
	
	if play_button:
		play_button.add_theme_stylebox_override("normal", button_style)
	
	# Style text elements
	if fps_label:
		fps_label.add_theme_color_override("font_color", Color(0.2, 0.9, 0.3, 1.0))
	
	# Enable BBCode for rich text labels
	if bot_info_label:
		bot_info_label.bbcode_enabled = true
	if tactical_info_label:
		tactical_info_label.bbcode_enabled = true
	if battle_info_label:
		battle_info_label.bbcode_enabled = true
	if events_label:
		events_label.bbcode_enabled = true

func load_battle_data_from_file(file_path: String):
	print("Attempting to load battle data from: ", file_path)
	var file = FileAccess.open(file_path, FileAccess.READ)
	if file == null:
		print("Error: Could not open battle file: ", file_path)
		create_test_scene()
		return false
	
	var json_string = file.get_as_text()
	file.close()
	
	var json = JSON.new()
	var parse_result = json.parse(json_string)
	if parse_result != OK:
		print("Error parsing JSON: ", json.get_error_message())
		create_test_scene()
		return false
	
	battle_data = json.data
	timeline = battle_data.get("timeline", [])
	metadata = battle_data.get("metadata", {})
	
	print("Battle data loaded - Timeline frames: ", timeline.size())
	print("Metadata: ", metadata)
	
	setup_arena()
	setup_timeline_slider()
	update_battle_info()
	
	print("✨ Battle data loaded successfully!")
	return true

func create_test_scene():
	print("Creating test scene with sample data...")
	
	# Create minimal test data
	timeline = [
		{
			"time": 0.0,
			"bots": [
				{"id": 0, "team": 0, "x": -5.0, "y": 0.0, "theta": 0.0, "hp": 100, "alive": true},
				{"id": 1, "team": 1, "x": 5.0, "y": 0.0, "theta": 180.0, "hp": 100, "alive": true}
			],
			"projectiles": [],
			"events": []
		}
	]
	
	metadata = {
		"arena_size": [20, 20],
		"walls": [
			[-10, -10, 20, 1, 0],  # Bottom wall
			[-10, 10, 20, 1, 0],   # Top wall  
			[-10, -10, 1, 20, 0],  # Left wall
			[10, -10, 1, 20, 0]    # Right wall
		],
		"winner": "test",
		"reason": "test_scene"
	}
	
	setup_arena()
	setup_timeline_slider()
	update_battle_info()
	
	print("Test scene created!")

func setup_arena():
	print("Setting up arena...")
	if not world_root:
		print("Error: world_root node not found!")
		return
		
	# Clear existing objects
	for node in bot_nodes.values():
		if is_instance_valid(node):
			node.queue_free()
	for node in projectile_nodes.values():
		if is_instance_valid(node):
			node.queue_free()
	for node in wall_nodes:
		if is_instance_valid(node):
			node.queue_free()
	
	bot_nodes.clear()
	projectile_nodes.clear()
	wall_nodes.clear()
	
	var arena_size = metadata.get("arena_size", [20, 20])
	var arena_width = arena_size[0]
	var arena_height = arena_size[1]
	
	print("Arena size: ", arena_width, "x", arena_height)
	
	# Create arena floor
	var floor_mesh = BoxMesh.new()
	floor_mesh.size = Vector3(arena_width, 0.2, arena_height)
	
	var floor_node = MeshInstance3D.new()
	floor_node.mesh = floor_mesh
	floor_node.material_override = floor_material
	floor_node.position = Vector3(0, -0.1, 0)
	world_root.add_child(floor_node)
	
	# Create walls
	var walls_data = metadata.get("walls", [])
	for wall_def in walls_data:
		create_wall(wall_def)
	
	# Position camera to view the arena
	camera_distance = max(arena_width, arena_height) * 1.5
	update_camera_position()

func create_wall(wall_def: Array):
	var center_x = wall_def[0]
	var center_y = wall_def[1]
	var width = wall_def[2]
	var height = wall_def[3]
	var angle_deg = wall_def[4]
	
	var wall_mesh = BoxMesh.new()
	wall_mesh.size = Vector3(width, 2.0, height)
	
	var wall_node = MeshInstance3D.new()
	wall_node.mesh = wall_mesh
	wall_node.material_override = wall_material
	wall_node.position = Vector3(center_x, 1.0, center_y)
	wall_node.rotation_degrees = Vector3(0, angle_deg, 0)
	
	world_root.add_child(wall_node)
	wall_nodes.append(wall_node)

func setup_timeline_slider():
	if timeline.size() > 0 and timeline_slider:
		timeline_slider.max_value = timeline.size() - 1
		timeline_slider.value = 0
		timeline_slider.step = 0.1
		print("Timeline slider configured for ", timeline.size(), " frames")
	else:
		print("Timeline slider not configured - timeline size: ", timeline.size())

func _input(event):
	if event is InputEventMouseButton:
		if event.button_index == MOUSE_BUTTON_RIGHT:
			is_panning = event.pressed
			last_mouse_pos = event.position
		elif event.button_index == MOUSE_BUTTON_WHEEL_UP:
			camera_distance = max(5.0, camera_distance - 2.0)
			update_camera_position()
		elif event.button_index == MOUSE_BUTTON_WHEEL_DOWN:
			camera_distance = min(100.0, camera_distance + 2.0)
			update_camera_position()
		elif event.button_index == MOUSE_BUTTON_LEFT and event.pressed:
			handle_bot_selection(event.position)
	
	elif event is InputEventMouseMotion and is_panning:
		var delta = (event.position - last_mouse_pos) * 0.01
		camera_angle_h -= delta.x
		camera_angle_v = clamp(camera_angle_v - delta.y, -80, 80)
		last_mouse_pos = event.position
		update_camera_position()
	
	elif event is InputEventKey and event.pressed:
		match event.keycode:
			KEY_SPACE:
				toggle_playback()
			KEY_LEFT:
				step_frame(-1)
			KEY_RIGHT:
				step_frame(1)
			KEY_R:
				reset_simulation()
			KEY_C:
				reset_camera()
			KEY_ESCAPE, KEY_Q:
				get_tree().quit()

func update_camera_position():
	var h_rad = deg_to_rad(camera_angle_h)
	var v_rad = deg_to_rad(camera_angle_v)
	
	var offset = Vector3(
		cos(v_rad) * sin(h_rad),
		sin(v_rad),
		cos(v_rad) * cos(h_rad)
	) * camera_distance
	
	camera_controller.position = camera_target + offset
	camera_3d.look_at(camera_target, Vector3.UP)

func handle_bot_selection(mouse_pos: Vector2):
	# Cast ray from camera to select bots
	var from = camera_3d.project_ray_origin(mouse_pos)
	var to = from + camera_3d.project_ray_normal(mouse_pos) * 1000.0
	
	var space_state = viewport_3d.world_3d.direct_space_state
	var query = PhysicsRayQueryParameters3D.create(from, to)
	var result = space_state.intersect_ray(query)
	
	if result and result.collider and result.collider.has_method("get_bot_id"):
		var bot_id = result.collider.get_bot_id()
		select_bot_by_id(bot_id)

func select_bot_by_id(bot_id: int):
	var current_state = get_current_state()
	for bot in current_state.get("bots", []):
		if bot.get("id") == bot_id:
			selected_bot = bot
			update_bot_info()
			break

func toggle_playback():
	playing = not playing
	play_button.text = "⏸ Pause" if playing else "▶ Play"

func step_frame(direction: int):
	playing = false
	play_button.text = "▶ Play"
	current_frame = clamp(current_frame + direction, 0, timeline.size() - 1)
	timeline_slider.value = current_frame

func reset_simulation():
	playing = false
	play_button.text = "▶ Play"
	current_frame = 0
	timeline_slider.value = 0

func reset_camera():
	camera_target = Vector3.ZERO
	camera_angle_h = 0.0
	camera_angle_v = -45.0
	update_camera_position()

func _process(delta):
	if playing and timeline.size() > 0:
		current_frame += 10.0 * playback_speed * delta
		if current_frame >= timeline.size() - 1:
			current_frame = timeline.size() - 1
			playing = false
			play_button.text = "▶ Play"
		timeline_slider.value = current_frame
	
	update_simulation()
	update_ui()
	
	# Update FPS
	if fps_label:
		fps_label.text = "FPS: " + str(Engine.get_frames_per_second())

func get_current_state() -> Dictionary:
	if timeline.is_empty():
		return {}
	
	var frame_idx = int(current_frame)
	var interp = current_frame - frame_idx
	
	frame_idx = clamp(frame_idx, 0, timeline.size() - 1)
	var next_frame_idx = min(frame_idx + 1, timeline.size() - 1)
	
	var state1 = timeline[frame_idx]
	if frame_idx == next_frame_idx:
		return state1
	
	var state2 = timeline[next_frame_idx]
	
	# Interpolate state
	var interp_state = state1.duplicate(true)
	
	# Interpolate bots
	var bots1 = {}
	var bots2 = {}
	for bot in state1.get("bots", []):
		bots1[bot.id] = bot
	for bot in state2.get("bots", []):
		bots2[bot.id] = bot
	
	var interp_bots = []
	for bot_id in bots1:
		if bot_id in bots2:
			var bot1 = bots1[bot_id]
			var bot2 = bots2[bot_id]
			var interp_bot = bot1.duplicate()
			
			interp_bot.x = lerp(bot1.x, bot2.x, interp)
			interp_bot.y = lerp(bot1.y, bot2.y, interp)
			
			# Handle angle wrapping
			var theta1 = bot1.theta
			var theta2 = bot2.theta
			var d_theta = theta2 - theta1
			if d_theta > 180:
				d_theta -= 360
			elif d_theta < -180:
				d_theta += 360
			interp_bot.theta = theta1 + d_theta * interp
			
			interp_bots.append(interp_bot)
	
	interp_state.bots = interp_bots
	return interp_state

func update_simulation():
	var state = get_current_state()
	update_bots(state)
	update_projectiles(state)

func update_bots(state: Dictionary):
	var current_bot_ids = {}
	for bot in state.get("bots", []):
		if bot.get("alive", true):
			current_bot_ids[bot.id] = true
	
	# Remove dead bots
	for bot_id in bot_nodes.keys():
		if not bot_id in current_bot_ids:
			bot_nodes[bot_id].queue_free()
			bot_nodes.erase(bot_id)
	
	# Update or create bots
	for bot in state.get("bots", []):
		if not bot.get("alive", true):
			continue
		
		var bot_id = bot.id
		var bot_node = bot_nodes.get(bot_id)
		
		if bot_node == null:
			bot_node = create_bot(bot_id, bot.team)
			bot_nodes[bot_id] = bot_node
		
		# Update position and rotation
		bot_node.position = Vector3(bot.x, 0.5, bot.y)
		bot_node.rotation_degrees = Vector3(0, bot.theta - 90, 0)
		
		# Update health bar
		update_bot_health_bar(bot_node, bot.hp)

func create_bot(bot_id: int, team: int) -> Node3D:
	var bot_container = Node3D.new()
	world_root.add_child(bot_container)
	
	# Main bot body (sphere)
	var body_mesh = SphereMesh.new()
	body_mesh.radius = 0.5
	body_mesh.height = 1.0
	
	var body_node = MeshInstance3D.new()
	body_node.mesh = body_mesh
	body_node.material_override = bot_material_blue if team == 0 else bot_material_red
	bot_container.add_child(body_node)
	
	# Direction indicator (cone)
	var cone_mesh = ConeMesh.new()
	cone_mesh.top_radius = 0.0
	cone_mesh.bottom_radius = 0.2
	cone_mesh.height = 0.4
	
	var cone_node = MeshInstance3D.new()
	cone_node.mesh = cone_mesh
	cone_node.material_override = body_node.material_override
	cone_node.position = Vector3(0, 0, 0.6)
	cone_node.rotation_degrees = Vector3(-90, 0, 0)
	body_node.add_child(cone_node)
	
	# Health bar background
	var health_bg = create_health_bar_quad(0.6, 0.08, Color.BLACK)
	health_bg.position = Vector3(0, 0.8, 0)
	body_node.add_child(health_bg)
	
	# Health bar fill
	var health_fill = create_health_bar_quad(0.6, 0.08, Color.GREEN)
	health_fill.position = Vector3(0, 0.8, 0.01)
	body_node.add_child(health_fill)
	
	# ID label
	var label = Label3D.new()
	label.text = str(bot_id)
	label.position = Vector3(0, 1.2, 0)
	label.billboard = BaseMaterial3D.BILLBOARD_ENABLED
	label.modulate = Color.WHITE
	body_node.add_child(label)
	
	# Store references for updates
	bot_container.set_meta("health_fill", health_fill)
	bot_container.set_meta("bot_id", bot_id)
	
	return bot_container

func create_health_bar_quad(width: float, height: float, color: Color) -> MeshInstance3D:
	var quad_mesh = QuadMesh.new()
	quad_mesh.size = Vector2(width, height)
	
	var material = StandardMaterial3D.new()
	material.albedo_color = color
	material.flags_unshaded = true
	material.no_depth_test = true
	
	var quad_node = MeshInstance3D.new()
	quad_node.mesh = quad_mesh
	quad_node.material_override = material
	
	return quad_node

func update_bot_health_bar(bot_node: Node3D, hp: float):
	var health_fill = bot_node.get_meta("health_fill")
	var hp_ratio = clamp(hp / 100.0, 0.0, 1.0)
	
	health_fill.scale.x = hp_ratio
	health_fill.position.x = -0.3 + (0.3 * hp_ratio)
	
	# Color based on health
	var health_color = Color.GREEN
	if hp_ratio < 0.3:
		health_color = Color.RED
	elif hp_ratio < 0.6:
		health_color = Color.YELLOW
	
	health_fill.material_override.albedo_color = health_color

func update_projectiles(state: Dictionary):
	var current_proj_ids = {}
	for proj in state.get("projectiles", []):
		if proj.has("id"):
			current_proj_ids[proj.id] = true
	
	# Remove expired projectiles
	for proj_id in projectile_nodes.keys():
		if not proj_id in current_proj_ids:
			projectile_nodes[proj_id].queue_free()
			projectile_nodes.erase(proj_id)
	
	# Update or create projectiles
	for proj in state.get("projectiles", []):
		if not proj.has("id"):
			continue
		
		var proj_id = proj.id
		var proj_node = projectile_nodes.get(proj_id)
		
		if proj_node == null:
			proj_node = create_projectile(proj.get("team", 0))
			projectile_nodes[proj_id] = proj_node
		
		proj_node.position = Vector3(proj.x, 0.5, proj.y)

func create_projectile(team: int) -> MeshInstance3D:
	var proj_mesh = SphereMesh.new()
	proj_mesh.radius = 0.15
	proj_mesh.height = 0.3
	
	var proj_node = MeshInstance3D.new()
	proj_node.mesh = proj_mesh
	proj_node.material_override = projectile_material_blue if team == 0 else projectile_material_red
	
	world_root.add_child(proj_node)
	return proj_node

func update_ui():
	update_battle_info()
	update_bot_info()

func update_battle_info():
	var state = get_current_state()
	var time_info = "Time: " + str(state.get("time", 0.0)) + "s"
	var frame_info = "Frame: " + str(int(current_frame)) + "/" + str(timeline.size() - 1)
	var speed_info = "Speed: " + str(playback_speed) + "x"
	
	var winner = metadata.get("winner", "unknown")
	var reason = metadata.get("reason", "unknown")
	
	var battle_text = "[font_size=18][color=cyan]BATTLE STATUS[/color][/font_size]\\n"
	battle_text += "============================================\\n"
	battle_text += "[color=white]" + time_info + "\\n" + frame_info + "\\n" + speed_info + "[/color]\\n"
	battle_text += "[color=yellow]Winner: " + str(winner) + " (" + str(reason) + ")[/color]"
	
	if battle_info_label:
		battle_info_label.text = battle_text

func update_bot_info():
	if selected_bot.is_empty():
		if bot_info_label:
			bot_info_label.text = "[font_size=16][color=white]Click on a bot to select it[/color][/font_size]"
		if tactical_info_label:
			tactical_info_label.text = ""
		return
	
	var bot = selected_bot
	var heading = bot.get("theta", 0.0)
	var vx = bot.get("vx", 0.0)
	var vy = bot.get("vy", 0.0)
	var speed = sqrt(vx * vx + vy * vy)
	var signal = bot.get("signal", "none")
	
	var bot_text = "[font_size=18][color=lime]BOT " + str(bot.id) + " (Team " + str(bot.team) + ")[/color][/font_size]\\n"
	bot_text += "----------------------------------------\\n"
	bot_text += "[color=white]HP: " + str(bot.hp) + "\\n"
	bot_text += "Position: (" + str(bot.x) + ", " + str(bot.y) + ")\\n"
	bot_text += "Heading: " + str(int(heading)) + "°  Speed: " + str(speed) + "\\n"
	bot_text += "Signal: " + str(signal) + "[/color]"
	
	if bot_info_label:
		bot_info_label.text = bot_text

func _on_play_button_pressed():
	toggle_playback()

func _on_timeline_slider_value_changed(value: float):
	current_frame = value

func _on_timeline_slider_drag_started():
	playing = false
	play_button.text = "▶ Play"

func _on_reset_button_pressed():
	reset_simulation()

func _on_step_back_pressed():
	step_frame(-1)

func _on_step_forward_pressed():
	step_frame(1)