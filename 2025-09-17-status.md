Summary

battle_sim.py:33 builds a deterministic pymunk-powered arena that tracks bots, projectiles, wall geometry, and event timelines for later visualization.
bot-runner-python.py:101 compiles LLM-provided Python bot functions (optionally via numba), enforces strict execution timeouts, and sanitizes returned actions before they reach the arena.
llm-python-gen.py:13 supplies templated aggressive/defensive/sniper behaviors and reproduces in-sim perception (FOV, occlusion) so bots receive consistent visible-object inputs.
run-battle-sim-python.py:40 orchestrates the match loop: compiling bot code, stepping physics/control ticks, recording summaries, and wiring battle logs into the viewer front-ends.
graphics-2d-simple.py:13 and graphics-3d-pygfx.py:1 render those timelines with interactive playback, bot selection, tactical overlays, and optional visibility debugging.
Next Steps

Fix the runner import in run-battle-sim-python.py:11 to point at bot-runner-python.py, otherwise the battle harness will fail to start.
Replace the Unix-only signal.alarm timeout in bot-runner-python.py:52 with a cross-platform approach (e.g., worker thread + timer) so Windows users can run matches.
Add a smoke test that runs run_python_battle end-to-end and asserts the generated summary keys, catching regressions in log/summary structure before they reach the viewers.
