Summary
NOTES TO LLMs:
Always run python code via uv run or uv python etc.

battle_arena.py:33 builds a deterministic pymunk-powered arena that tracks bots, projectiles, wall geometry, and event timelines for later visualization.
bot_runner_python.py:101 now compiles LLM-provided Python bot functions inside a RestrictedPython sandbox, enforces tight execution timeouts, and sanitizes returned actions (including bounded per-bot memory) before they reach the arena.
llm_bot_controller.py:13 supplies templated aggressive/defensive/sniper behaviors and reproduces in-sim perception (FOV, occlusion) so bots receive consistent visible-object inputs.
battle_runner_cli.py:40 orchestrates the match loop: compiling bot code, stepping physics/control ticks, recording summaries, and wiring battle logs into the viewer front-ends.
viewer_2d_pygame.py:13 and viewer_3d_pygfx.py:1 render those timelines with interactive playback, bot selection, tactical overlays, and optional visibility debugging.
Next Steps

Fix the runner import in battle_runner_cli.py:11 to point at bot_runner_python.py, otherwise the battle harness will fail to start.
Replace the Unix-only signal.alarm timeout in bot_runner_python.py:52 with a cross-platform approach (e.g., worker thread + timer) so Windows users can run matches.
Add a smoke test that runs run_python_battle end-to-end and asserts the generated summary keys, catching regressions in log/summary structure before they reach the viewers.


Critique of control design:
Here’s a focused review of the current Python-function control path and how it lines up with your three questions.

Short Answers

Bot functions have enough for simple reactive control, but not for robust, stateful tactics. Key self-state and history are missing.
LLMs don’t get enough info yet to write better next-gen code; there’s no feedback loop or API contract/prompt data wired in.
The signaling scaffold is promising, but emergent team comms will be weak without a team bus or “last heard” memory beyond line-of-sight.
What Bot Functions Receive

API: bot_function(observation) where observation bundles visible_objects, self (id/team/pose/vel/hp/cooldown/can_fire/tick/time), move_history, world params, allowed_signals, and prior memory. Results still resolve to move|fire|rotate|dodge plus optional signal, and may return a bounded memory dict for the next tick (bot_runner_python.py:333; llm_bot_controller.py:127–305).
Sensors: ray-marched visible_objects with occlusion; includes walls (intersections), enemies/friends (pos, vel, hp, id, team, bearing, distance, signal), projectiles (pos, vel, ttl) (llm_bot_controller.py:127, 199–236, 238–269, 271–289).
State history: move_history carries the last 12 sanitized actions with tick/time context (llm_bot_controller.py:167–207, 314–351).
Frequency: functions run ~5 Hz (every 24 control ticks at 120 Hz) (battle_runner_cli.py:108–121, 141–143).
Actions mapping: set_single_bot_action handles move (to x,y), fire (aim at x,y), rotate (absolute deg), dodge (deg) (battle_arena.py:299–391).
Gaps Impacting Control

Missing self-state: ✅ Addressed 2025-09-17 – observation.self includes id, team, pose, velocity, hp, cooldown_remaining, can_fire, time, tick (llm_bot_controller.py:214–240).
No memory: ✅ Addressed 2025-09-17 – runner now accepts/returns sanitized per-bot memory dicts (bot_runner_python.py:271–313, 356–409).
Empty move_history: ✅ Addressed 2025-09-17 – controller records the last 12 actions with tick/time context (llm_bot_controller.py:167–207, 302–321).
Hidden world params: ✅ Addressed 2025-09-17 – observation.params exposes key arena constants (llm_bot_controller.py:242–259).
Unknown shot gating: ✅ Addressed 2025-09-17 – observation.self includes cooldown_remaining and can_fire sourced from battle_arena.get_fire_status (battle_arena.py:125–153, 402–440).
Rate control: 5 Hz is fine but should be configurable per bot/personality to explore “varying frequency” controllers (battle_runner_cli.py:108–121).
Do LLMs Get Enough To Write Better Code Next Time?

Current flow assigns static templates (llm_bot_controller.py:24–35, 314–510). There is no prompt, no API doc, no telemetry feedback, no validation results fed back.
For code-improving loops, the LLM needs:
A stable, explicit API contract for inputs/outputs with examples and edge cases (bot_runner_python.py:259–278, 333–360; battle_arena.py:299–391).
Per-bot metrics and summaries: hit_rate, damage, kills, deaths, timeouts/errors, execution-time budget usage (battle_arena.py:960–1052 for scoring; runner stats bot_runner_python.py:426–432; battle_runner_cli.py:157–176).
Compact battle traces: e.g., last N decisions, observations, and outcomes; confidence flags for whether actions were no-ops due to gating.
Safety/test harness results: compile/log of exceptions, schema violations, timeouts; unit-style checks the code must satisfy (no recursion, bounded loops, no imports, <X ms avg).
Suggest wiring a “trainer” phase that:
Exports a small training bundle per bot (contract, stats, top mistakes, short episode traces).
Prompts the LLM to emit new code; compiles + runs a brief eval arena; compares deltas.
Accepts code only if it meets latency/safety/score thresholds.
Emergent Signals

Good foundations:
Enumerated, sanitized signals (bot_runner_python.py:50–78; sanitize at 353–360).
Signals are visible from teammates that are visible in FOV (llm_bot_controller.py:219–236).
Limitations:
Line-of-sight only: if teammates aren’t visible (occluded/out of FOV), their signal isn’t available; this weakens team cohesion in spread-out play.
No payload beyond a symbol; that limits expressivity.
Line-of-sight signaling remains an intentional constraint for now; richer team buses are deferred until we have stronger safety tooling for inter-bot comms.
Improvements:
Add a team bus with latency/noise: team_signals listing each teammate’s last signal + age, optionally even if not visible. Or keep “last heard” in a persisted memory channel.
Optional small numeric payload: e.g., signal_data with 1–2 bounded scalars (e.g., urgency, target angle/id) for richer emergent protocols without opening the door to arbitrary data.
Log and expose to LLM how signal usage correlates with outcomes to incentivize its emergent development.
Safety and Robustness Concerns

Timeout containment: threads can’t be killed; a timed-out function keeps running in the background (bot_runner_python.py:96–125). Move execution into a subprocess (per call or per bot) with cgroups/rlimits for real wall-time and memory limits; kill on timeout.
Import surface: __import__ is allowed in builtins (bot_runner_python.py:205–229), so bot code can import os/sys/.... Remove __import__, pre-bind only safe modules (math, maybe a small random) and reject import statements via AST validation.
Top-level effects: exec(source_code, namespace) runs all top-level code before you ever call the function (bot_runner_python.py:231–239). Parse AST and only allow a single function def named bot_function with no top-level code.
Pre-exec checks: add static checks (no while True, no comprehensions with large ranges, no globals, bounded list sizes) and a micro-benchmark to reject slow code prior to battle.
High-Impact, Low-Risk Changes

Add self-state and params to inputs; fill move_history; keep visible_objects as-is for now:
battle_runner_cli.py:114–121 to pass self_state, params, move_history.
llm_bot_controller.py: add real move history tracking and a get_self_state helper.
Add per-bot memory pass-through: let function return {..., 'memory': {...}} and feed back next call (sanitize keys/values).
Make function-call rate configurable via CLI and per-bot personality (battle_runner_cli.py:108–121).
Harden the runner:
Remove __import__; AST-validate only a pure def bot_function(...).
Run bot function in a subprocess with a strict wall-time/memory limit.
Wire LLM training loop:
Export a compact per-bot training bundle after each battle.
Provide a clear API contract doc and minimal examples alongside failure logs.
If you’d like, I can:

Draft the input schema change (self_state/params/memory) and update the runner and controller.
Add a CLI flag for function-call frequency and a per-bot override.
Harden the runner by stripping imports and adding an AST gate.
