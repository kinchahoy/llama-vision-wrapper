Summary
NOTES TO LLMs:
Always run python code via uv run or uv python etc.

battle_arena.py:33 builds a deterministic pymunk-powered arena that tracks bots, projectiles, wall geometry, and event timelines for later visualization.
bot_runner_python.py:101 compiles LLM-provided Python bot functions (optionally via numba), enforces strict execution timeouts, and sanitizes returned actions before they reach the arena.
llm_bot_controller.py:13 supplies templated aggressive/defensive/sniper behaviors and reproduces in-sim perception (FOV, occlusion) so bots receive consistent visible-object inputs.
battle_runner_cli.py:40 orchestrates the match loop: compiling bot code, stepping physics/control ticks, recording summaries, and wiring battle logs into the viewer front-ends.
viewer_2d_pygame.py:13 and viewer_3d_pygfx.py:1 render those timelines with interactive playback, bot selection, tactical overlays, and optional visibility debugging.
Next Steps

Fix the runner import in battle_runner_cli.py:11 to point at bot_runner_python.py, otherwise the battle harness will fail to start.
Replace the Unix-only signal.alarm timeout in bot_runner_python.py:52 with a cross-platform approach (e.g., worker thread + timer) so Windows users can run matches.
Add a smoke test that runs run_python_battle end-to-end and asserts the generated summary keys, catching regressions in log/summary structure before they reach the viewers.
